using UnityEditor;
using UnityEditor.Build;
using System.Collections.Generic;
using System.Reflection;
using System.Text;
using System.IO;
using UnityEngine;
using System;

namespace Cu1uSFX.Internal
{
    /// <summary>
    /// The class that generates the SFX enum
    /// </summary>
    public static class SFXEnumGenerator
    {
        /// <summary>
        /// Regenerates the enum script. If you run this manually, make sure to tell Unity to recompile script changes afterwards.
        /// </summary>
        public static void GenerateEnumScript()
        {
            ref SFXDefinition[] definitions = ref SFXList.Instance.Definitions;
            string[] names = new string[definitions.Length];
            for (int i = 0; i < definitions.Length; i++)
            {
                names[i] = definitions[i].Name;
            }
            GenerateEnumScriptFromNames(names, GetEnumScriptPath());
            SFXList.Instance.EnumNames = new List<string>(names);
            //DefineManager.AddCompileDefine(SFX_GENERATED_DIRECTIVE);
        }
        public static string GetEnumScriptPath()
        {
            SFXList.MakeSureSFXEnumScriptPathIsValid();
            return SFXList.Instance.SFXEnumScriptPath;
        }
        /// <summary>
        /// Regenerates the enum script from a specified list of names, onto the script at <paramref name="scriptPath"/>. 
        /// Index N will be linked to sound effect #N in the Sound Effects menu, regardless of name.
        /// </summary>
        /// <param name="enumNames">The names to use for the enums.</param>
        /// <param name="scriptPath">Path to the script to be overwritten.</param>
        static void GenerateEnumScriptFromNames(string[] enumNames, string scriptPath)
        {
            List<string> addedNames = new();

            using StreamWriter writer = new(scriptPath);

            writer.WriteLine("namespace Cu1uSFX");
            writer.WriteLine("{");
            writer.WriteLine("    // [Cu1uSFX]");
            writer.WriteLine("    // DO NOT EDIT - this file is automatically generated by SFXEnumGenerator as you define sounds in the SFX List asset. Changes made here will be overwritten.");
            writer.WriteLine("    // DO NOT MOVE THIS FILE - A new one will be generated. Instead, change the location of this script by assigning a new target in the SFX List in /Assets/Resources/SFX List");
            writer.WriteLine("    public static class SFX");
            writer.WriteLine("    {");
            for (int i = 0; i < enumNames.Length; i++)
            {
                string line = FormatEnumName(enumNames[i]);

                if (string.IsNullOrEmpty(line))
                    continue;
                if (addedNames.Contains(line))
                    continue;

                addedNames.Add(line);

                line = $"        public readonly static {nameof(PredefinedSFX)} {line} = new({i});";

                writer.WriteLine(line);
            }
            writer.WriteLine("    }");
            writer.WriteLine("}");
        }

        /// <summary>
        /// Turns an unsanitized input string into a code-safe variable/enum name, by stripping non-alphanumeric characters and capping string length, 
        /// as well as making sure the first character isn't a number.
        /// </summary>
        /// <param name="name">The input name to sanitize.</param>
        /// <returns>Sanitized alphanumeric string.</returns>
        public static string FormatEnumName(string name)
        {
            StringBuilder sb = new();
            int chars = 0;
            foreach (char c in name)
            {
                if (chars > 50) break; // Caps length at 50 chars
                if (char.IsLetter(c))
                {
                    sb.Append(c);
                    chars++;
                    continue;
                }
                if (char.IsNumber(c) && sb.Length != 0)
                {
                    sb.Append(c);
                    chars++;
                    continue;
                }
            }
            return sb.ToString();
        }

        /// <summary>
        /// Tries to make unity recompile all scripts.
        /// </summary>
        public static void RecompileScripts()
        {
#if UNITY_2019_3_OR_NEWER
            UnityEditor.Compilation.CompilationPipeline.RequestScriptCompilation();
#elif UNITY_2017_1_OR_NEWER
            System.Reflection.Assembly editorAssembly = System.Reflection.Assembly.GetAssembly(typeof(Editor));
            System.Type editorCompilationInterfaceType = editorAssembly.GetType("UnityEditor.Scripting.ScriptCompilation.EditorCompilationInterface");
            System.Reflection.MethodInfo dirtyAllScriptsMethod = editorCompilationInterfaceType.GetMethod("DirtyAllScripts", System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Public);
            dirtyAllScriptsMethod.Invoke(editorCompilationInterfaceType, null);
#endif
        }
        [Obsolete] public const string SFX_GENERATED_DIRECTIVE = "SFX_ENUM_GENERATED";
    }

    /// <summary>
    /// Tools for adding or removing compile defines for all build targets.
    /// </summary>
    [Obsolete]
    public static class DefineManager
    {
        public static void AddCompileDefine(string newDefineConstant)
        {
            foreach (NamedBuildTarget buildTarget in GetNamedBuildTargets())
            {
                string definesString = PlayerSettings.GetScriptingDefineSymbols(buildTarget);
                List<string> defines = new(definesString.Split(';'));
                if (defines.Contains(newDefineConstant))
                {
                    continue;
                }
                defines.Add(newDefineConstant);
                StringBuilder sb = new();
                sb.AppendJoin(';', defines);
                PlayerSettings.SetScriptingDefineSymbols(buildTarget, sb.ToString());
            }
        }

        public static void RemoveCompileDefine(string defineConstant)
        {
            foreach (NamedBuildTarget buildTarget in GetNamedBuildTargets())
            {
                string definesString = PlayerSettings.GetScriptingDefineSymbols(buildTarget);
                List<string> defines = new(definesString.Split(';'));
                if (!defines.Contains(defineConstant))
                {
                    continue;
                }
                defines.Remove(defineConstant);
                StringBuilder sb = new();
                sb.AppendJoin(';', defines);
                PlayerSettings.SetScriptingDefineSymbols(buildTarget, sb.ToString());
            }
        }

        static List<NamedBuildTarget> GetNamedBuildTargets()
        {
            List<NamedBuildTarget> targets = new();
            BuildTargetGroup[] groups = {
                BuildTargetGroup.Standalone,
                BuildTargetGroup.iOS,
                BuildTargetGroup.Android,
                BuildTargetGroup.WebGL
            };
            foreach (BuildTargetGroup group in groups)
            {
                NamedBuildTarget namedTarget = NamedBuildTarget.FromBuildTargetGroup(group);
                targets.Add(namedTarget);
            }
            return targets;
        }
    }
}