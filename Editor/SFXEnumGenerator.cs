using UnityEditor;
using UnityEditor.Build;
using System.Collections.Generic;
using System.Reflection;
using System.Text;
using System.IO;
using UnityEngine;
using System;

namespace Cu1uSFX.Internal
{
    public static class SFXEnumGenerator
    {
        public const string SFX_GENERATED_DIRECTIVE = "SFX_ENUM_GENERATED";

        public static void GenerateEnumScript()
        {
            ref SFXDefinition[] definitions = ref SFXList.Instance.Definitions;
            string[] names = new string[definitions.Length];
            for (int i = 0; i < definitions.Length; i++)
            {
                names[i] = definitions[i].Name;
            }
            GenerateEnumScriptFromNames(names, GetEnumScriptPath());
            SFXList.Instance.EnumNames = new List<string>(names);
            DefineManager.AddCompileDefine(SFX_GENERATED_DIRECTIVE);
        }
        public static string GetEnumScriptPath()
        {
            SFXList.MakeSureSFXEnumScriptPathIsValid();
            return SFXList.Instance.SFXEnumScriptPath;
        }

        static void GenerateEnumScriptFromNames(string[] enumNames, string scriptPath)
        {
            List<string> addedNames = new();

            using StreamWriter writer = new(scriptPath);

            writer.WriteLine("#if " + SFX_GENERATED_DIRECTIVE);

            writer.WriteLine("namespace Cu1uSFX");
            writer.WriteLine("{");
            writer.WriteLine("    // DO NOT EDIT - this file is automatically generated by SFXList_Editor as you define sounds in the SFX List asset. Changes made here will be overwritten.");
            writer.WriteLine("    public enum SFX");
            writer.WriteLine("    {");
            writer.WriteLine("        None = 0" + (enumNames.Length > 0 ? "," : string.Empty));
            for (int i = 1; i <= enumNames.Length; i++)
            {
                string line = FormatEnumName(enumNames[i - 1]);

                if (string.IsNullOrEmpty(line))
                    continue;
                if (addedNames.Contains(line))
                    continue;

                addedNames.Add(line);

                line = $"        {line}";
                if (i != enumNames.Length)
                    line += ",";
                writer.WriteLine(line);
            }
            writer.WriteLine("    }");
            writer.WriteLine("}");

            writer.WriteLine("#endif");
        }

        public static string FormatEnumName(string name)
        {
            StringBuilder sb = new();
            foreach (char c in name)
            {
                if (char.IsLetter(c))
                {
                    sb.Append(c);
                    continue;
                }
                if (char.IsNumber(c) && sb.Length != 0)
                {
                    sb.Append(c);
                    continue;
                }
            }
            return sb.ToString();
        }

        public static void RecompileScripts()
        {
#if UNITY_2019_3_OR_NEWER
            UnityEditor.Compilation.CompilationPipeline.RequestScriptCompilation();
#elif UNITY_2017_1_OR_NEWER
            System.Reflection.Assembly editorAssembly = System.Reflection.Assembly.GetAssembly(typeof(Editor));
            System.Type editorCompilationInterfaceType = editorAssembly.GetType("UnityEditor.Scripting.ScriptCompilation.EditorCompilationInterface");
            System.Reflection.MethodInfo dirtyAllScriptsMethod = editorCompilationInterfaceType.GetMethod("DirtyAllScripts", System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Public);
            dirtyAllScriptsMethod.Invoke(editorCompilationInterfaceType, null);
#endif
        }
    }

    public static class DefineManager
    {
        public static void AddCompileDefine(string newDefineConstant)
        {
            foreach (NamedBuildTarget buildTarget in GetNamedBuildTargets())
            {
                string definesString = PlayerSettings.GetScriptingDefineSymbols(buildTarget);
                List<string> defines = new(definesString.Split(';'));
                if (defines.Contains(newDefineConstant))
                {
                    continue;
                }
                defines.Add(newDefineConstant);
                StringBuilder sb = new();
                sb.AppendJoin(';', defines);
                PlayerSettings.SetScriptingDefineSymbols(buildTarget, sb.ToString());
            }
        }

        public static void RemoveCompileDefine(string defineConstant)
        {
            foreach (NamedBuildTarget buildTarget in GetNamedBuildTargets())
            {
                string definesString = PlayerSettings.GetScriptingDefineSymbols(buildTarget);
                List<string> defines = new(definesString.Split(';'));
                if (!defines.Contains(defineConstant))
                {
                    continue;
                }
                defines.Remove(defineConstant);
                StringBuilder sb = new();
                sb.AppendJoin(';', defines);
                PlayerSettings.SetScriptingDefineSymbols(buildTarget, sb.ToString());
            }
        }

        static List<NamedBuildTarget> GetNamedBuildTargets()
        {
            List<NamedBuildTarget> targets = new();
            BuildTargetGroup[] groups = {
                BuildTargetGroup.Standalone,
                BuildTargetGroup.iOS,
                BuildTargetGroup.Android,
                BuildTargetGroup.WebGL
            };
            foreach (BuildTargetGroup group in groups)
            {
                NamedBuildTarget namedTarget = NamedBuildTarget.FromBuildTargetGroup(group);
                targets.Add(namedTarget);
            }
            return targets;
            // var staticFields = typeof(NamedBuildTarget).GetFields(BindingFlags.Public | BindingFlags.Static);
            // var buildTargets = new List<NamedBuildTarget>();
            // foreach (var staticField in staticFields)
            // {
            //     // Exclude 'Unknown' - this can throw errors when used with certain methods.
            //     if (staticField.Name == "Unknown")
            //         continue;
            //     try
            //     {
            //         if (staticField.FieldType == typeof(NamedBuildTarget))
            //             buildTargets.Add((NamedBuildTarget)staticField.GetValue(null));
            //     }
            //     catch (Exception) {}
            // }
            // return buildTargets;
        }
    }
}